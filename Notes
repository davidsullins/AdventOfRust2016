Problem 1 part 1.

Originally I wrote a pure functional implementation with a fold() in calc_manhattan_length. But state needed to be kept in 2 places, the current position and the current direction. I decided that was harder to read than just mutating the direction as we go, so I changed it.

Problem 3 part 2.

I really wanted to create something functional and elegant for part 2 like I did for part 1. While it's pretty compact and it makes perfect sense to me, I wonder if it would be clearer if I had written it out with for loops and kept a counter variable. It would be more code and look messier to me, but might be easier to follow for someone not inside my functional head.

After looking over others' solutions, it hit me that I gave a more complicated solution to part 2 because I reused my is_triangle_possible implementation from part 1. I should have rewritten it to create a simpler solution overall.

Also, that code I stuck in main for part 2 really deserves its own function and a unit test.

Problem 4.

I solved the first part without using regexes, but after looking at the second part it was clear that using a regex would give a clearer and simpler solution. It would be cleaner overall to rewrite part 1 and make the whole thing use a regex.

Problem 5.

To avoid reallocating a string for every index that's tested, I create a string in get_password, truncate it on each iteration and append the new number at the end. Truncation should not change the string's capacity.

Problem 7.

Solution was very straightforward. The windows() iterator on slices comes in handy for many Advent of Code problems. I first considered parsing the string carefully to find things inside brackets, then realized that if the brackets are balanced we can simply split the string everywhere we find [ or ] and the resulting list will alternate between outside brackets and inside brackets. This solution would fail if the problem input contained tricks like including a [ inside a hypernet sequence.

Problem 8.

Because the light grid is so small (50 x 6 = 300 bytes) I went with a 2D array of bools for the data storage. If the display had been huge I would have been tempted to pull in the bit_vec crate. Bit twiddling is rarely worth the trouble when storing relatively small amounts of data.

To rotate a column or row I just make a copy. There are more efficient ways to rotate an array than that (look up "juggling algorithm" for example) but again, for the small amount of data here it doesn't seem worth it.

Problem 9.

For part 2, originally I tried making the recursive function take an Iterator argument, with the idea that I could call take(...) to make it iterate over a subset of the string slice iterator. This failed to compile because it woud recursively expand the type argument, so that it was Take<Chars> the first time, and Take<Take<Chars>> the second time, etc. I think I could have made it work using a boxed iterator but I really would have been disappointed if I had to resort to dynamic dispatch, so I changed it to the current method using string slices. I think the solution is quite readable anyway, so I am not disappointed in where it ended up.

Problem 12.

It wasn't clear to me from the instructions that the jnz instruction has an immediate form as well as a register form. I only found out when I ran my problem input. Unknown whether the immediate forms of cpy and jnz could take negative numbers as input, but I handle them anyway. The only negative numbers that appeared in my problem input were jump offsets.

My initial implementation turns out to be quite slow, taking about 20 seconds to complete both parts on my PC. It parses each instruction every time using a regex. That clearly could be optimized. I will return to this later.

Problem 13.

Simple breadth-first search to solve this problem. BFS means the first time we find the goal, it's already the shortest possible path so no need to keep exploring.

Problem 14.

Personal note, I really dig problems like this. It has a straightforward solution that is easy to implement but slow. With careful optimization you can make it much more efficient. In this case, the straightforward solution is to search for triples and then when you find a triple, search forward 1000 indices for matching quints. But that forces you to search for the same quints again and again. The optimized form I implemented creates queues of triples and quints. I read ahead by 1000 indices and then check the oldest triples for any matching quints. I throw away the triples as I go, but because quints are extremely rare I don't bother throwing the oldest away. Would have just added a bit more code for no measurable performance benefit.

For the second part, again there was a straightforward implementation (formatted write of the MD5 sum) that turned out to be quite slow when performed 2016 times for each index. Profiling with valgrind/callgrind showed most of the time spent in formatted write operations. I replaced it with a simple table lookup for a big performance boost. After that, profiling showed most of the time spent in MD5-related functions. The only further optimization I might consider would be to try some other MD5 Rust implementations to see if there's a faster option.


